---
layout: default
navsection: admin
title: User activation
...

{% comment %}
Copyright (C) The Arvados Authors. All rights reserved.

SPDX-License-Identifier: CC-BY-SA-3.0
{% endcomment %}

After completing the authentication process with the SSO server and receiving a new @identity_url@, a new user object is always created.

h3. Auto setup

If @auto_setup_new_users@ is true, as part of creating the new user object, the user is immediately setup with:

* @can_login@ @permission@ link going (email address &rarr; user uuid) which records @identity_url_prefix@ (??? wtf does this mean)
* Membership in the "All users" group (can read all users, all users can see new user)
* A new git repo and @can_manage@ permission if @auto_setup_new_users_with_repository@ is true
* @can_login@ permission to a shell node if @auto_setup_new_users_with_vm_uuid@ is set to the uuid of a vm

h3. is_active

A newly created user is inactive (@is_active@ is false) by default unless @new_users_are_active@.

An inactive user cannot create or update any object, but can read Arvados objects that the user account has permission to read.  This implies that if @auto_setup_new_users@ is true, an "inactive" user who has been set up may still be able to do things, such as read things shared with "All users", clone and push to the git repository, or login to a vm.  (unless these services check is_active)

(I believe that when this was originally designed, being able to access git and VM required an ssh key, and an inactive user could not register an ssh key because that required creating a record.  However, it is now possible to authenticate to shell VMs and http+git with just an API token).

At this point, there are two ways a user can become active:

# An admin can set the @is_active@ field directly.  This runs @setup_on_activate@ which sets up oid_login_perm and group membership, but does not set repo or vm (even if if @auto_setup_new_users_with_repository@ and/or @auto_setup_new_users_with_vm_uuid@ are set).
# Calling to the @activate@ method of the users controller.   (see below).

h3. User agreements

The @activate@ method of the users controller.  This checks if the user @is_invited@ and whether the user has signed all the clickthrough agreements.

@is_invited@ is true if any of these are true:
* @is_active@ is true
* @new_users_are_active@ is true
* the user account has a permission link to read the system "all users" group.

Clickthrough agreements are accessed by getting a listing on the @user_agreements@ endpoint.  This returns a list of collection uuids.  This is executed as a system user, so it bypasses normal read permission checks.

The available user agreements are represented in the links table as @link_class: signature@ and @name: require@ and (system_user_uuid &rarr; uuid of collection containing user agreement text file)

On workbench, it checks @is_invited@.  If true, it displays the clickthrough agreements which the user can "sign".  If @is_invited@ is false, the user ends up at the "inactive user" page.

The @user_agreements/sign@ endpoint creates a Link with @link_class: signature@ and @name: click@ and (current user uuid &rarr; collection uuid). This is executed as a system user, so it bypasses the restriction that inactive users cannot create objects.

The @user_agreements/signatures@ endpoint returns the list of Link objects that represent signatures by the current user (created by @sign@).

h3. Typical flows

h4. Open instance

Policy: anybody who shows up and signs the agreements is activated.

<pre>
auto_setup_new_users: true
new_users_are_active: false
</pre>

# User is created and auto-setup.  At this point, @is_active@ is false, but user has been added to "All users" group.
# Workbench checks @is_invited@ and finds it is true, because the user is a member of "All users" group.
# Workbench presents user with list of user agreements, user reads and clicks "sign" for each one.
# Workbench tries to activate user.
# User is activated.

h4. Private instance

Policy: users must be manually approved.

<pre>
auto_setup_new_users: false
new_users_are_active: false
</pre>

# User is created.  Not set up.  @is_active@ is false.
# Workbench checks @is_invited@ and finds it is false.  User gets "inactive user" page.
# Admin goes to user page and clicks either "setup user" or manually @is_active@ to true.
# Clicking "setup user" sets up the user.  This includes adding the user to "All users" which qualifies the user as @is_invited@.
# On refreshing workbench, the user is still inactive, but is able to self-activate after signing clickthrough agreements (if any).
# Alternately, directly setting @is_active@ to true also sets up the user, but workbench won't display clickthrough agreements (because the user is already active).

h4. Developer instance

Policy: avoid wasting developer's time clicking through extra pages.

<pre>
auto_setup_new_users: true
new_users_are_active: true
</pre>

# User is created and auto-setup.  Also sets @is_active@ to true.
# User can immediately start using workbench.

h3. User profile

The user profile is checked by workbench after checking if user agreements need to be signed.  The requirement to fill out the user profile is not enforced by the API server.

h3. Deactivating users

Setting @is_active@ is not sufficient to lock out a user.  The user can call @activate@ to become active again.  Instead, use @unsetup@:

* Delete oid_login_perms
* Delete git repository permission links
* Delete VM login permission links
* Remove from "All users" group
* Delete any "signatures"
* Clear preferences / profile
* Mark as inactive

Does not revoke @is_admin@ though!  Maybe we need to fix that?

Does not prevent user from reading things?
